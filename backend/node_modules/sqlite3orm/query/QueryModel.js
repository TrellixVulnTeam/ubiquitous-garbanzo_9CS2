"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryModel = void 0;
const QueryCondition_1 = require("./QueryCondition");
const QueryModelBase_1 = require("./QueryModelBase");
const QueryModelPredicates_1 = require("./QueryModelPredicates");
const Where_1 = require("./Where");
class QueryModel extends QueryModelBase_1.QueryModelBase {
    constructor(type) {
        super(type);
    }
    /**
     * count all models using an optional filter
     *
     * @param sqldb - The database connection
     * @param [filter] - An optional Filter-object
     * @param [params] - An optional object with additional host parameter
     * @returns promise of the number of models
     */
    countAll(sqldb, filter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                params = Object.assign({}, params);
                const select = yield this.getSelectStatementForColumnExpression('COUNT(*) as result', filter || {}, params);
                const row = yield sqldb.get(select, params);
                return row.result || 0;
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(new Error(`count '${this.table.name}' failed: ${e.message}`));
            }
        });
    }
    /**
     * check if model exist using an optional filter
     *
     * @param sqldb - The database connection
     * @param [filter] - An optional Filter-object
     * @param [params] - An optional object with additional host parameter
     * @returns promise for boolean result
     */
    exists(sqldb, filter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                params = Object.assign({}, params);
                const subQuery = yield this.getSelectStatementForColumnExpression('1', filter || {}, params);
                const select = `SELECT EXISTS(\n${subQuery}) as result\n`;
                const row = yield sqldb.get(select, params);
                return row.result ? true : false;
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(new Error(`count '${this.table.name}' failed: ${e.message}`));
            }
        });
    }
    /**
     * Select one model using an optional filter
     *
     * @param sqldb - The database connection
     * @param [filter] - An optional Filter-object
     * @param [params] - An optional object with additional host parameter
     * @returns A promise of the selected model instance; rejects if result is not exactly one row
     */
    selectOne(sqldb, filter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                params = Object.assign({}, params);
                const select = yield this.getSelectStatement(this.toSelectAllColumnsFilter(filter), params);
                const rows = yield sqldb.all(select, params);
                if (rows.length != 1) {
                    return Promise.reject(new Error(`select '${this.table.name}' failed: unexpectedly got ${rows.length} rows`));
                }
                return this.updateModelFromRow(new this.type(), rows[0]);
            }
            catch (e) {
                return Promise.reject(new Error(`select '${this.table.name}' failed: ${e.message}`));
            }
        });
    }
    /**
     * Select all models using an optional filter
     *
     * @param sqldb - The database connection
     * @param [filter] - An optional Filter-object
     * @param [params] - An optional object with additional host parameter
     * @returns A promise of array of model instances
     */
    selectAll(sqldb, filter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                params = Object.assign({}, params);
                const select = yield this.getSelectStatement(this.toSelectAllColumnsFilter(filter), params);
                const rows = yield sqldb.all(select, params);
                const results = [];
                rows.forEach((row) => {
                    results.push(this.updateModelFromRow(new this.type(), row));
                });
                return results;
            }
            catch (e) {
                return Promise.reject(new Error(`select '${this.table.name}' failed: ${e.message}`));
            }
        });
    }
    /**
     * Select all partial models using a filter
     *
     * @param sqldb - The database connection
     * @param filter - A Filter-object
     * @param [params] - An optional object with additional host parameter
     * @returns A promise of array of partial models
     */
    selectPartialAll(sqldb, filter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                params = Object.assign({}, params);
                const select = yield this.getSelectStatement(filter, params);
                const rows = yield sqldb.all(select, select);
                const results = [];
                rows.forEach((row) => {
                    results.push(this.getPartialFromRow(row));
                });
                return results;
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(new Error(`select '${this.table.name}' failed: ${e.message}`));
            }
        });
    }
    /**
     * Select a given model by ID
     *
     * @param sqldb - The database connection
     * @param model - The input/output model
     * @returns A promise of the model instance
     */
    selectModel(sqldb, model) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const row = yield sqldb.get(this.getSelectByIdStatement(), this.bindPrimaryKeyInputParams(model));
                model = this.updateModelFromRow(model, row);
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(new Error(`select '${this.table.name}' failed: ${e.message}`));
            }
            return model;
        });
    }
    /**
     * Select a model by given partial model
     *
     * @param sqldb - The database connection
     * @param input - The partial model providing the ID
     * @returns A promise of the model
     */
    selectModelById(sqldb, input) {
        return __awaiter(this, void 0, void 0, function* () {
            let model = new this.type();
            try {
                const row = yield sqldb.get(this.getSelectByIdStatement(), this.bindPrimaryKeyInputParams(input));
                model = this.updateModelFromRow(model, row);
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(new Error(`select '${this.table.name}' failed: ${e.message}`));
            }
            return model;
        });
    }
    /*
     * select each model using a callback
     */
    selectEach(sqldb, callback, filter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                params = Object.assign({}, params);
                const select = yield this.getSelectStatement(this.toSelectAllColumnsFilter(filter), params);
                const res = yield sqldb.each(select, params, (err, row) => {
                    // TODO: err?
                    callback(err, this.updateModelFromRow(new this.type(), row));
                });
                return res;
            }
            catch (e) {
                return Promise.reject(new Error(`select '${this.table.name}' failed: ${e.message}`));
            }
        });
    }
    getWhereClause(filter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!filter || !filter.where) {
                return '';
            }
            let where = filter.where;
            if (typeof where === 'string') {
                where = where.trimLeft();
                if (!where.length) {
                    return '';
                }
                if (where.substring(0, 5).toUpperCase() !== 'WHERE') {
                    return `WHERE ${where}`;
                }
                return where;
            }
            const tableAlias = filter.tableAlias ? filter.tableAlias : undefined;
            const tablePrefix = tableAlias && tableAlias.length ? `${tableAlias}.` : '';
            let oper;
            if ((0, Where_1.isModelPredicates)(where)) {
                oper = new QueryModelPredicates_1.QueryModelPredicates(where);
            }
            else {
                oper = new QueryCondition_1.QueryCondition(where);
            }
            const whereClause = yield oper.toSql(this.metaModel, params, tablePrefix);
            return whereClause.length ? `WHERE ${whereClause}` : whereClause;
        });
    }
    getSelectStatement(filter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let sql = this.getSelectAllStatement(this.getSelectColumns(filter), filter.tableAlias);
                sql += yield this.getNonColumnClauses(filter, params);
                return sql;
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    getSelectStatementForColumnExpression(colexpr, filter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let sql = this.getSelectAllStatementForColumnExpression(colexpr, filter.tableAlias);
                sql += yield this.getNonColumnClauses(filter, params);
                return sql;
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(e);
            }
        });
    }
    getSelectColumns(filter) {
        if (!filter.select) {
            return undefined;
        }
        const columns = [];
        for (const key in filter.select) {
            if (Object.prototype.hasOwnProperty.call(filter.select, key) && filter.select[key]) {
                const prop = this.metaModel.properties.get(key);
                if (!prop) {
                    continue;
                }
                columns.push(key);
            }
        }
        return columns.length ? columns : undefined;
    }
    getNonColumnClauses(filter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            let sql = '';
            const whereClause = yield this.getWhereClause(filter, params);
            if (whereClause.length) {
                sql += `  ${whereClause}\n`;
            }
            const orderByClause = this.getOrderByClause(filter);
            if (orderByClause.length) {
                sql += `  ${orderByClause}\n`;
            }
            const limitClause = this.getLimitClause(filter);
            if (limitClause.length) {
                sql += `  ${limitClause}\n`;
            }
            const offsetClause = this.getOffsetClause(filter);
            if (offsetClause.length) {
                sql += `  ${offsetClause}\n`;
            }
            return sql;
        });
    }
    getOrderByClause(filter) {
        if (!filter || !filter.order) {
            return '';
        }
        const columns = [];
        for (const key in filter.order) {
            /* istanbul ignore if */
            if (!Object.prototype.hasOwnProperty.call(filter.order, key)) {
                continue;
            }
            const prop = this.metaModel.properties.get(key);
            if (!prop) {
                continue;
            }
            if (filter.order[key]) {
                columns.push(prop.field.quotedName);
            }
            else {
                columns.push(`${prop.field.quotedName} DESC`);
            }
        }
        if (!columns.length) {
            return '';
        }
        const tableAlias = filter.tableAlias ? filter.tableAlias : undefined;
        const tablePrefix = tableAlias && tableAlias.length ? `${tableAlias}.` : '';
        return `ORDER BY ${tablePrefix}` + columns.join(`, ${tablePrefix}`);
    }
    getLimitClause(filter) {
        if (!filter || !filter.limit) {
            return '';
        }
        return `LIMIT ${filter.limit}`;
    }
    getOffsetClause(filter) {
        if (!filter || !filter.offset) {
            return '';
        }
        return ` OFFSET ${filter.offset}`;
    }
    toSelectAllColumnsFilter(filter) {
        const res = Object.assign({}, filter);
        if (res.select) {
            delete res.select;
        }
        return res;
    }
}
exports.QueryModel = QueryModel;
//# sourceMappingURL=QueryModel.js.map